<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Design Patterns on ZhengWei Liu&#39;s blogs</title>
    <link>https://blog.zhengweiliu.com/categories/design-patterns/</link>
    <description>Recent content in Design Patterns on ZhengWei Liu&#39;s blogs</description>
    <image>
      <url>https://blog.zhengweiliu.com/mountain-cover.png</url>
      <link>https://blog.zhengweiliu.com/mountain-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 08 Mar 2023 21:15:20 +0800</lastBuildDate><atom:link href="https://blog.zhengweiliu.com/categories/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Design Patterns - Factory Method Pattern</title>
      <link>https://blog.zhengweiliu.com/posts/design-pattern/factory-method-pattern/</link>
      <pubDate>Wed, 08 Mar 2023 21:15:20 +0800</pubDate>
      
      <guid>https://blog.zhengweiliu.com/posts/design-pattern/factory-method-pattern/</guid>
      <description>利用 Factory Method Pattern - Design Patterns 學習設計模式 Factory Method Pattern，並利用 Python 撰寫 sample code. 摘要 Factory Method Pattern 簡明扼要的說，就是定義 製作者(Creator) 和 產品(Produc</description>
    </item>
    
    <item>
      <title>Design Patterns - Decorator Pattern</title>
      <link>https://blog.zhengweiliu.com/posts/design-pattern/decorator-pattern/</link>
      <pubDate>Wed, 01 Mar 2023 22:40:29 +0800</pubDate>
      
      <guid>https://blog.zhengweiliu.com/posts/design-pattern/decorator-pattern/</guid>
      <description>Decorator Pattern 透過修改已定義的行為，以擴展或變更其功能，而不需透過繼承和覆寫。 使用組合 (composition) 替代繼承 (inherit)，可動態地添加或移除行為，且不需要在繼承關係中堆疊子類別。 Decorator模式更具靈活性和可維護性，因此被廣泛地應用於軟體開發領域中。</description>
    </item>
    
    <item>
      <title>Design Patterns - Observer Pattern</title>
      <link>https://blog.zhengweiliu.com/posts/design-pattern/observer-pattern/</link>
      <pubDate>Wed, 22 Feb 2023 20:41:43 +0800</pubDate>
      
      <guid>https://blog.zhengweiliu.com/posts/design-pattern/observer-pattern/</guid>
      <description>在 Observer Pattern 中，將會明確定義出兩種角色 : 1. IObservable : 被觀察者，如上述的 Server (A類), 2. IObserver : 觀察者，如上述的 Client (B類) 。讓 Server 主動推送(Push)狀態變更的信號給 Client，可以有效的改善輪詢帶來的缺點。</description>
    </item>
    
    <item>
      <title>Design Patterns - Strategy Pattern</title>
      <link>https://blog.zhengweiliu.com/posts/design-pattern/strategy-pattern/</link>
      <pubDate>Wed, 22 Feb 2023 11:32:13 +0800</pubDate>
      
      <guid>https://blog.zhengweiliu.com/posts/design-pattern/strategy-pattern/</guid>
      <description>相對於繼承(inherit)， Strategy Pattern 則是組合優於繼承(composition over inheritance)的精神。假設有一個薪水計算器要給兩個不同的客戶使用 : 速食業客戶以每小時時薪和工時來核算薪水，外送業客戶以每單獎金和總外送單數來核算薪水。薪水計算器需要提供給不同業者不同核算薪水的方法， Strategy Pattern 則提供了一種方式，使得不同業者可以使用同一個計算器，並選擇不同的核算方式，來獲取薪水計算的結果。</description>
    </item>
    
  </channel>
</rss>
